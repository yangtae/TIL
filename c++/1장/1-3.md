### C++ 참조자(레퍼런스)의 도입

```c++
#include <iostream>

int changeVal(int *p) {
    *p = 3;
    
    return 0;
}

int main() {
    int number = 5;
    std::cout << number << std::endl;
    changeVal(&number);
    std::cout << number << std::endl;
}
```

changeVal 함수의 인자 p에 number의 주소값을 전달하여, *p를 통해 number를 참조하여 number의 값을 3으로 바꾸었다.



---------

포인터

```c++
int x;
```

- CPU가 위 문장을 실행하면 RAM 메모리 조각이 따로 설정된다. 예를 들어 변수 x에 메모리 위치 140이 할당 되었다고 가정해보자. 프로그램에서 변수 x를 표현식 또는 명령문으로 접근할 때마다 값을 얻으려면 메모리 위치 140을 찾아야 한다.

- 변수의 좋은 점은 우리가 어떤 특정한 메모리 주소가 할당되는지 걱정할 필요가 없는 것이다. 지정된 식별자로 변수를 참조하면 컴파일러에서 이 이름을 할당된 메모리 주소로 변환한다.

  하지만 이 접근법에는 몇가지 제한사항이 있으며 다음의 내용에서 살펴본다



##### 주소연산자 (&)

```c++
#include <iostream>

int main() {
	int x = 5;
    std::cout << x << std::endl;
    std::cout << &x << std::endl;
    
    return 0;
}
//prints 
// 5
// 0027FEA0
```



##### 역참조 연산자(*)

```c++
#include <iostream>

int main() {
	int x = 5;
	std::cout << x << std::endl;
	std::cout << &x << std::endl;
	std::cout << *&x << std::endl;
	
	return 0;
}
//prints
//5
//0027FEA0
//5
```



##### 포인터

- 포인터는 어떠한 값을 저장하는게 아닌 메모리 주소를 저장하는 변수다.



##### 포인터 선언

- 포인터 변수는 일반 변수처럼 선언되며, 자료형과 변수 이름 사이에 별표(*)가 붙는다
- 자료형 * 포인터 이름;

```c++
int* iPtr; //int형 포인터
double* dPtr; //double형 포인터

int* iPtr2, *iPtr3;
```



##### 포인터에 값 할당

- 포인터는 메모리 주소만 저장하므로, 포인터에 값을 할당할 때 그 값은 주소여야만 한다. 포인터로 하는 가장 흔한 작업은 다른 변수의 주소를 저장하는 것이다



- 변수의 주소를 얻으려면 주소 연산자(&)를 사용한다
  - 포인터 = &변수

```c++
int value = 5;
int &ptr = &value; //변수값의 주소로 ptr초기화
```

개념적으로 위코드를 다음과 같이 나타낼 수 있다.

![image-20211115220537935](C:\Users\yts\AppData\Roaming\Typora\typora-user-images\image-20211115220537935.png)

- ptr은 값으로 value 변수 값의  주소를 가지고 있다. 그러므로 ptr을 value 변수를 가리키는 값이라고 할 수 있다.

```c++
#include <iostream>

int main(){
	int value = 5;
    int *ptr = &value; //변수값의 주소로 ptr초기화
    
    std::cout << &value << std::endl;
    std::cout << ptr << std::endl;
}
//0012FF7C
//0012FF7C
```

포인터 변수의 자료형은 가리키는 변수의 자료형과 같아야 한다



다음 사항은 올바르지 않은 예이다

```c++
int *ptr = 5;
```

- 포인터가 주소만 보유할 수 있고 정수 리터럴 5에는 메모리 주소가 없기 때문이다. 위 코드를 시도하면 컴파일러는 정수를 정수 포인터로 변환할 수 없으므로 오류가 발생한다.

- C++에서는 포인터에 리터럴 메모리 주소를 직접 할당할 수 없다.



##### Dereferencing Pointers

- 어떤 것을 가리키는 포인터 변수가 있다면, 역참조 연산자 *를 통해 포인터가 가리키는 주소의 값을 알 수 있다.

```c++
int value = 5;
std::cout << &value << std::endl; //value의 주소를 출력
std::cout << value << std::endl; //value의 값을 출력

int *ptr = &value;
std::cout << ptr << std::endl; // ptr이 가리키는 주소를 출력한다 (=&value)
std::cout << *ptr <<std::endl; //ptr을 역참조한다 

//0012FF7C
//5
//0012FF7C
//5
```

- *ptr은 value와 같게 취급되므로 마치 변수값인 것처럼 값을 할당할 수 있다.



##### 포인터의 크기

- 포인터의 크기는 실행 파일이 컴파일된 아키텍처에 따라 달라진다. 32비트 실행 파일은 32비트 메모리 주소를 사용하므로 포인터의 크기는 32비트(4바이트)이다. 64비트의 경우에는 8바이트이다



##### 포인터의 장점

포인터는 여러 가지 경우에서 유용하다

- 배열은 포인터를 사용하여 구현된다. 포인터는 배열을 반복할 때 사용할 수 있다.(배열 인덱스 대신 사용 가능)
- C++에서 동적으로 메모리를 할당할 수 있는 유일한 방법이다. (가장 흔한 사용 사례)
- 데이터를 복사하지 않고도 많은 양의 데이터를 함수에 전달할 수 있다.
- 상속을 다룰 때 다형성을 달성하기 위해 사용한다
- 하나의 구조체/클래스 포인터를 다른 구조체/클래스에 두어 체인을 형성하는 데 사용할 수 있다. 이는 연결리스트 및 트리와 같은 고급 자료구조에서 유용하다.

----------

