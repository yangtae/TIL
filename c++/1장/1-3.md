### C++ 참조자(레퍼런스)의 도입

```c++
#include <iostream>

int changeVal(int *p) {
    *p = 3;
    
    return 0;
}

int main() {
    int number = 5;
    std::cout << number << std::endl;
    changeVal(&number);
    std::cout << number << std::endl;
}
//5
//3
```

changeVal 함수의 인자 p에 number의 주소값을 전달하여, *p를 통해 number를 참조하여 number의 값을 3으로 바꾸었다.

- C언어에서는 어떠한 변수를 가리키고 싶을 땐 반드시 포인터를 사용해야만 했다. 그런데 C++에서는 다른 변수나 상수를 가리키는 방법으로 또 달느 방식을 제공하는데 이를 참조자(래퍼런스)라고 부른다



```c++
#include <iostream>

int main() {
	int a = 3;
    int &another_a = a;
    
    another_a = 5;
    std::cout << "a : " << a << std::endl;
    std::cout << "another_a : " << another_a << std::endl;
    
    return 0;
}

// a : 5
// another_a : 5
```

- 먼저 int형 변수인 a를 정의하고 그 안에 3이란 값을 넣어주었다.
- 그 후에 a의 참조자 another_a를 정의하였다. 이 때 참조자를 정하는 방법은 가리키고자 하는 타입 뒤에 &를 붙이면 된다
- 이말인 즉슨 another_a는 a의 또다른 이름이라고 컴파일러에게 알려주는 것이다. 따라서 another_a에 어떠한 작업을 수행하든 이는 사실상 a에 그 작업을 하는 것과 마찬가지이다.
- 그래서 another_a를 5로 수정을 하면 a도 같이 5로 바뀌는 것을 확인할 수 있다.
- 하지만 래퍼런스와 포인터는 몇가지 중요한 차이점이 있다



- 래퍼런스는 반드시 처음에 누구의 별명이 될 것인지 정해야 한다

```c++
int &another_a;
```

이와 같은 문장은 불가능 하다 하지만 포인터의 경우

```c++
int* p
```

는 전혀 문제 없는 코드이다

래퍼런스의 또 한가지 중요한 특징은 한번 어떤 변수의 참조자가 되버리면 더이상 다른 변수를 참조할 수 없게 된다



##### 래퍼런스의 배열과 배열의 래퍼런스

- 먼저 레퍼런스의 배열이 과연 가능한 것인지에 대해 부터 생각해보자. 앞서 말했듯이 레퍼런스는 반드시 정의화 함께 초기화를 해주어야 한다. 

```c++
int a,b;
int &arr[2] = {a,b};
```

컴파일을 해보면 에러가 발생한다. 래퍼런스의 포인터는 존재할 수 없다

주고값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다는 의미와 같다. 하지만 래퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지하지 않는다. 따라서 이런 모순 때문에 언어차원에서 레퍼런스의 배열을 정의하는 것은 언어 차원에서 금지한다.

하지만 배열들의 레퍼런스는 가능하다

---------

포인터

```c++
int x;
```

- CPU가 위 문장을 실행하면 RAM 메모리 조각이 따로 설정된다. 예를 들어 변수 x에 메모리 위치 140이 할당 되었다고 가정해보자. 프로그램에서 변수 x를 표현식 또는 명령문으로 접근할 때마다 값을 얻으려면 메모리 위치 140을 찾아야 한다.

- 변수의 좋은 점은 우리가 어떤 특정한 메모리 주소가 할당되는지 걱정할 필요가 없는 것이다. 지정된 식별자로 변수를 참조하면 컴파일러에서 이 이름을 할당된 메모리 주소로 변환한다.

  하지만 이 접근법에는 몇가지 제한사항이 있으며 다음의 내용에서 살펴본다



##### 주소연산자 (&)

```c++
#include <iostream>

int main() {
	int x = 5;
    std::cout << x << std::endl;
    std::cout << &x << std::endl;
    
    return 0;
}
//prints 
// 5
// 0027FEA0
```



##### 역참조 연산자(*)

```c++
#include <iostream>

int main() {
	int x = 5;
	std::cout << x << std::endl;
	std::cout << &x << std::endl;
	std::cout << *&x << std::endl;
	
	return 0;
}
//prints
//5
//0027FEA0
//5
```



##### 포인터

- 포인터는 어떠한 값을 저장하는게 아닌 메모리 주소를 저장하는 변수다.



##### 포인터 선언

- 포인터 변수는 일반 변수처럼 선언되며, 자료형과 변수 이름 사이에 별표(*)가 붙는다
- 자료형 * 포인터 이름;

```c++
int* iPtr; //int형 포인터
double* dPtr; //double형 포인터

int* iPtr2, *iPtr3;
```



##### 포인터에 값 할당

- 포인터는 메모리 주소만 저장하므로, 포인터에 값을 할당할 때 그 값은 주소여야만 한다. 포인터로 하는 가장 흔한 작업은 다른 변수의 주소를 저장하는 것이다



- 변수의 주소를 얻으려면 주소 연산자(&)를 사용한다
  - 포인터 = &변수

```c++
int value = 5;
int &ptr = &value; //변수값의 주소로 ptr초기화
```

개념적으로 위코드를 다음과 같이 나타낼 수 있다.

![image-20211115220537935](C:\Users\yts\AppData\Roaming\Typora\typora-user-images\image-20211115220537935.png)

- ptr은 값으로 value 변수 값의  주소를 가지고 있다. 그러므로 ptr을 value 변수를 가리키는 값이라고 할 수 있다.

```c++
#include <iostream>

int main(){
	int value = 5;
    int *ptr = &value; //변수값의 주소로 ptr초기화
    
    std::cout << &value << std::endl;
    std::cout << ptr << std::endl;
}
//0012FF7C
//0012FF7C
```

포인터 변수의 자료형은 가리키는 변수의 자료형과 같아야 한다



다음 사항은 올바르지 않은 예이다

```c++
int *ptr = 5;
```

- 포인터가 주소만 보유할 수 있고 정수 리터럴 5에는 메모리 주소가 없기 때문이다. 위 코드를 시도하면 컴파일러는 정수를 정수 포인터로 변환할 수 없으므로 오류가 발생한다.

- C++에서는 포인터에 리터럴 메모리 주소를 직접 할당할 수 없다.



##### Dereferencing Pointers

- 어떤 것을 가리키는 포인터 변수가 있다면, 역참조 연산자 *를 통해 포인터가 가리키는 주소의 값을 알 수 있다.

```c++
int value = 5;
std::cout << &value << std::endl; //value의 주소를 출력
std::cout << value << std::endl; //value의 값을 출력

int *ptr = &value;
std::cout << ptr << std::endl; // ptr이 가리키는 주소를 출력한다 (=&value)
std::cout << *ptr <<std::endl; //ptr을 역참조한다 

//0012FF7C
//5
//0012FF7C
//5
```

- *ptr은 value와 같게 취급되므로 마치 변수값인 것처럼 값을 할당할 수 있다.



##### 포인터의 크기

- 포인터의 크기는 실행 파일이 컴파일된 아키텍처에 따라 달라진다. 32비트 실행 파일은 32비트 메모리 주소를 사용하므로 포인터의 크기는 32비트(4바이트)이다. 64비트의 경우에는 8바이트이다



##### 포인터의 장점

포인터는 여러 가지 경우에서 유용하다

- 배열은 포인터를 사용하여 구현된다. 포인터는 배열을 반복할 때 사용할 수 있다.(배열 인덱스 대신 사용 가능)
- C++에서 동적으로 메모리를 할당할 수 있는 유일한 방법이다. (가장 흔한 사용 사례)
- 데이터를 복사하지 않고도 많은 양의 데이터를 함수에 전달할 수 있다.
- 상속을 다룰 때 다형성을 달성하기 위해 사용한다
- 하나의 구조체/클래스 포인터를 다른 구조체/클래스에 두어 체인을 형성하는 데 사용할 수 있다. 이는 연결리스트 및 트리와 같은 고급 자료구조에서 유용하다.

----------

